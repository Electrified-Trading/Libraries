// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© Electrified (electrifiedtrading)

// @version=5
// @description Provides functions for simplifying operations with collections of x+y coordinates.  Where x is typically a bar index or time (millisecond) value.
library('Vector')

export new(int size = 0) =>
    [array.new_int(size), array.new_float(size)]

export size(int[] xA, float[] yA) =>
    if array.size(xA) != array.size(yA)
        runtime.error('Vector arrays are out of sync.')
    array.size(xA)  

checkBounds(int[] xA, float[] yA, int index) =>
    if size(xA, yA) <= index
        runtime.error('Requested index is greater than available.')  
    else if index < 0
        runtime.error('Index is less than zero.')

export get(int[] xA, float[] yA, int index) =>
    checkBounds(xA, yA, index)
    [array.get(xA, index), array.get(yA, index)]

export set(int[] xA, float[] yA, int index, int x, float y) =>
    checkBounds(xA, yA, index)
    array.set(xA, index, x)
    array.set(yA, index, y)
    [index, x, y]

export push(int[] xA, float[] yA, int x, float y) =>
    len = size(xA, yA)
    array.push(xA, x)
    array.push(yA, y)
    [len, x, y]

export unshift(int[] xA, float[] yA, int x, float y) =>
    size(xA, yA) // validate
    array.unshift(xA, x)
    array.unshift(yA, y)
    [0, x, y]

export insert(int[] xA, float[] yA, int index, int x, float y) =>
    checkBounds(xA, yA, index)
    array.insert(xA, index, x)
    array.insert(yA, index, y)
    [index, x, y]

export pop(int[] xA, float[] yA) =>
    if size(xA, yA) == 0
        [int(na), float(na)]
    else
        [array.pop(xA), array.pop(yA)]

export shift(int[] xA, float[] yA) =>
    if size(xA, yA) == 0
        [int(na), float(na)]
    else
        [array.shift(xA), array.shift(yA)]

export remove(int[] xA, float[] yA, int index) =>
    [x, y] = get(xA, yA, index)
    array.remove(xA, index)
    array.remove(yA, index)
    [x, y]

getLast(int[] xA, int start) =>
    size = array.size(xA)
    if not na(start)
        if start >= size
            runtime.error("Value of 'start' is greater than available.")
        start
    else
        size - 1

export allIndexesBetween(int[] xA, int lo, int hi, int start = na, bool ordered = false) =>
    int[] indexes = array.new_int()
    last = na(lo) or na(hi) ? -1 : getLast(xA, start)
    while last >= 0
        x = array.get(xA, last)
        if x <= lo
            if ordered
                last := -1
        else if x < hi
            array.push(indexes, last)
        last -= 1
    array.reverse(indexes) // because unshifting is expensive
    indexes

export lastIndexBetween(int[] xA, int lo, int hi, int start = na, bool ordered = false) =>
    int index = -1
    last = na(lo) or na(hi) ? -1 : getLast(xA, start)
    while index == -1 and last >= 0
        x = array.get(xA, last)
        if x <= lo
            if ordered
                last := -1
        else if x < hi
            index := last
        last -= 1
    index

export lastIndexBelow(int[] xA, int hi, int start = na) =>
    int index = -1
    last = na(hi) ? -1 : getLast(xA, start)
    while index == -1 and last >= 0
        if array.get(xA, last) < hi
            index := last
        last -= 1
    index